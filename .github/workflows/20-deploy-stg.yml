name: '20: Stg Deployment'

# MANUAL deployment to stg for pre-production validation
# stg: stg.zenphry.com
# Purpose: Test release candidate with same artifact that will go to prod
# To deploy: Go to Actions → Deploy to Staging (stg) → Run workflow → Select release branch
# See docs/CICD.md for complete documentation

on:
  workflow_dispatch:
    inputs:
      branch:
        description: 'Release branch to deploy (e.g., release/2025-01-20-1430)'
        required: true
        type: string

jobs:
  # Validate inputs and get release branch SHA (fail fast)
  get-release-sha:
    name: Validate & Get SHA
    runs-on: ubuntu-latest
    outputs:
      sha: ${{ steps.get-sha.outputs.sha }}
    steps:
      # Fail fast: validate branch match before any checkout
      - name: Validate workflow branch matches input branch
        run: |
          WORKFLOW_REF="${{ github.ref }}"
          INPUT_BRANCH="${{ github.event.inputs.branch }}"

          # Extract branch name from refs/heads/...
          WORKFLOW_BRANCH="${WORKFLOW_REF#refs/heads/}"

          echo "[CHECK] Workflow 'Use workflow from': $WORKFLOW_BRANCH"
          echo "[CHECK] Input branch parameter: $INPUT_BRANCH"

          if [ "$WORKFLOW_BRANCH" != "$INPUT_BRANCH" ]; then
            echo ""
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "[ERROR] BRANCH MISMATCH - Deployment blocked"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo ""
            echo "The 'Use workflow from' dropdown must match the branch input."
            echo ""
            echo "To fix:"
            echo "  1. Click 'Run workflow' dropdown"
            echo "  2. Change 'Use workflow from' to: $INPUT_BRANCH"
            echo "  3. Enter the same branch in the input field"
            echo "  4. Click 'Run workflow'"
            echo ""
            exit 1
          fi

          echo "[OK] Branch match verified: $WORKFLOW_BRANCH"

      - name: Checkout release branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch }}

      - name: Get release branch SHA
        id: get-sha
        run: |
          SHA=$(git rev-parse HEAD)
          echo "sha=$SHA" >> $GITHUB_OUTPUT
          echo "[ARTIFACT] Release branch SHA: $SHA"

  # Run quality checks with release branch context
  quality-checks:
    name: Quality Checks
    needs: [get-release-sha]
    uses: ./.github/workflows/00-ci.yml

  deploy:
    name: Deploy to stg
    needs: [get-release-sha, quality-checks]
    runs-on: ubuntu-latest

    steps:
      - name: Checkout release branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch }}

      - name: Setup Node.js environment
        uses: ./.github/actions/setup-node

      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: build-dist-${{ needs.get-release-sha.outputs.sha }}

      - name: Extract build artifact
        run: |
          tar -xzf build-dist.tar.gz
          rm build-dist.tar.gz
          echo "[OK] Build artifacts extracted"
          ls -la build/

      - name: Get current stg version for rollback
        id: backup-version
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          # Get current stg version ID (active version with 100% traffic)
          # NOTE: Deployments are sorted oldest to newest, so we use .[-1] to get the most recent
          CURRENT_VERSION=$(npx wrangler deployments list --env stg --json 2>/dev/null | jq -r '.[-1].versions[] | select(.percentage == 100) | .version_id // "none"')
          echo "version_id=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "[ARTIFACT] Current stg version for rollback: $CURRENT_VERSION"

      - name: Deploy to stg
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          command: deploy --env stg

      - name: Wait for edge propagation with progressive health checks
        run: |
          echo "[WAIT] Waiting for Cloudflare edge propagation..."
          echo "[INFO] Starting progressive health checks with linear backoff (max 3 minutes)"

          URL="https://stg.zenphry.com"
          MAX_WAIT=180
          ATTEMPT=1
          TOTAL_WAIT=0
          CURRENT_WAIT=5

          # Start with minimal initial wait
          echo "[WAIT] Initial wait: ${CURRENT_WAIT} seconds..."
          sleep $CURRENT_WAIT
          TOTAL_WAIT=$CURRENT_WAIT

          while [ $TOTAL_WAIT -lt $MAX_WAIT ]; do
            echo "[CHECK] Attempt $ATTEMPT - Testing $URL (waited ${TOTAL_WAIT}s total)..."
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$URL" 2>/dev/null || echo "000")

            if [ "$HTTP_CODE" == "200" ]; then
              echo "[OK] Deployment is live! (HTTP $HTTP_CODE)"
              echo "[INFO] Total wait time: ${TOTAL_WAIT} seconds"
              break
            fi

            # Linear backoff: 5s, 10s, 15s, 20s, 30s, 30s, 30s...
            CURRENT_WAIT=$(( CURRENT_WAIT < 30 ? CURRENT_WAIT + 5 : 30 ))

            if [ $(( TOTAL_WAIT + CURRENT_WAIT )) -le $MAX_WAIT ]; then
              echo "[WAIT] Not ready yet (HTTP $HTTP_CODE), waiting ${CURRENT_WAIT}s..."
              sleep $CURRENT_WAIT
              TOTAL_WAIT=$(( TOTAL_WAIT + CURRENT_WAIT ))
            else
              echo "[WARN] Max wait time reached. Proceeding with health checks..."
              break
            fi

            ATTEMPT=$((ATTEMPT + 1))
          done

      - name: Run stg health checks
        id: health-check
        continue-on-error: true
        run: |
          chmod +x ./scripts/01-health-check.sh
          bash ./scripts/01-health-check.sh https://stg.zenphry.com

      - name: Auto-rollback on health check failure
        if: steps.health-check.outcome == 'failure'
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          BACKUP_VERSION="${{ steps.backup-version.outputs.version_id }}"
          if [ "$BACKUP_VERSION" != "none" ]; then
            echo "[ERROR] Health checks failed. Rolling back to version $BACKUP_VERSION"
            npx wrangler rollback --env stg --message "Auto-rollback after health check failure"
            echo "[OK] Rollback completed to previous working version"
          else
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "[FAIL] DEPLOYMENT FAILED - Health Checks Failed"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo ""
            echo "[ERROR] This appears to be the first deployment to stg environment."
            echo "        No previous version exists for automatic rollback."
            echo ""
            echo "[INFO] Recovery Options:"
            echo "       1. Review health check logs above to identify the issue"
            echo "       2. Fix the deployment issue in the release branch"
            echo "       3. Re-run this workflow after fixing the issue"
            echo "       4. If critical, deploy a hotfix release branch"
            echo ""
            echo "[INFO] Note: Auto-rollback will be available after the first successful deployment."
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            exit 1
          fi

      - name: Verify rollback health
        if: steps.health-check.outcome == 'failure'
        run: |
          echo "[WAIT] Waiting 30 seconds for rollback to propagate..."
          sleep 30
          echo "[CHECK] Verifying rolled-back deployment..."
          chmod +x ./scripts/01-health-check.sh
          bash ./scripts/01-health-check.sh https://stg.zenphry.com
